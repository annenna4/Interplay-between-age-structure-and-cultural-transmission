function [Ecount,Fcount] = get_WFpredictions(nSam,k,simMax,simpson0,prob0)

% calculation of the number of samples of size n with k variants generated by a WF process that have a probility (diversity) smaller than the one of the observed sample

name = sprintf('./data/WFprediction/simpson_WF_n%02d_k%02d.mat',nSam,k); % loading diversity values generated by simMax configurations possible under neutral evolution, i.e. sampled from Ewens sampling distribution, with nSam and k
if exist(name,'file')
    
    simpson = load(name);
    simpson = simpson.simpson;
    name = sprintf('./data/WFprediction/prob_WF_n%02d_k%02d.mat',nSam,k); % loading probability values generated by simMax configurations possible under neutral evolution with nSam and k
    prob = load(name);
    prob = prob.prob;
    
    index = find(simpson<=simpson0); % find all diversity values smaller than the oberved one
    Fcount = length(index)/length(simpson); % estimate of the probability that the observed sample has a diversity smaller than samples generated under neutral evolution 
    index = find(prob<=prob0); % find all probability values smaller than the oberved one
    Ecount = length(index)/length(prob);  % estimate of the tail probability that the observed sample has a probability smaller than samples generated under neutral evolution 
    
else % WF predictions for specific (nSam,k) are not known and have to be calculated
    
    %Sampling from ESF (according to the algorithm by Steward 1978) and
    %generating neutral predictions for diversity + probability
    
	%Calculation of B(n,k) through recurrence relation
	%It holds B(0,0) = 1, B(0,n) = 0, B(n,0) = 0
	B = zeros(nSam+1,nSam+1);
	B(1,1) = 1;
	B(1,2:end) = zeros(1,nSam);
	B(2:end,1) = zeros(nSam,1);
	for k1 = 1:nSam
    	for n1 = 1:nSam
        	B(k1+1,n1+1) = (k1*B(k1,n1)+(n1-1)*B(k1+1,n1))/(n1);    
    	end
	end
	B(1,:) = [];
	B(:,1) = [];
        
    Fcount = 0; Ecount = 0;
    prob = zeros(1,length(simMax)); simpson = zeros(1,length(simMax));
    
    for sim = 1:simMax
        
        if k>1
            
            n = ones(1,k);
            %choosing of n(1)
            alpha = rand;
            P = B(k-1,nSam-n(1))/(B(k,nSam)*n(1));
            while P<alpha
                n(1) = n(1)+1;
                P = P+B(k-1,nSam-n(1))/(B(k,nSam)*n(1));
            end
            %choosing of n(i), i=2,...,k-1
            for i=2:k-1
                alpha = rand;
                P = B(k-i,nSam-sum(n(1:i)))/(B(k-i+1,nSam-sum(n(1:(i-1))))*n(i));
                while P<alpha
                    n(i) = n(i)+1;
                    P = P+B(k-i,nSam-sum(n(1:i)))/(B(k-i+1,nSam-sum(n(1:(i-1))))*n(i));
                end
            end
            n(k) = nSam-sum(n(1:k-1));
            
            nRel = n./nSam;
            simpson(sim) = sum(nRel.^2);
            prob(sim) = 1/prod(n);
            
        else
            
            simpson(sim) = 1;
            prob(sim) = 1/nSam;
            
        end
    end
    
    index = find(prob<=prob0);
    Ecount = length(index)/simMax;
    index = find(simpson<=simpson0);
    Fcount = length(index)/simMax;
    
    name = sprintf('./data/WFprediction/simpson_WF_n%02d_k%02d.mat',nSam,k)
    save(name,'simpson')
    name = sprintf('./data/WFprediction/prob_WF_n%02d_k%02d.mat',nSam,k)
    save(name,'prob')
    
    B = [];
end




